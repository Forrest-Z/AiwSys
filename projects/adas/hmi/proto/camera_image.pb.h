// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camera_image.proto

#ifndef PROTOBUF_INCLUDED_camera_5fimage_2eproto
#define PROTOBUF_INCLUDED_camera_5fimage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_camera_5fimage_2eproto 

namespace protobuf_camera_5fimage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_camera_5fimage_2eproto
namespace watrix {
namespace proto {
class CameraImage;
class CameraImageDefaultTypeInternal;
extern CameraImageDefaultTypeInternal _CameraImage_default_instance_;
class CameraImages;
class CameraImagesDefaultTypeInternal;
extern CameraImagesDefaultTypeInternal _CameraImages_default_instance_;
class DetectionBox;
class DetectionBoxDefaultTypeInternal;
extern DetectionBoxDefaultTypeInternal _DetectionBox_default_instance_;
class DetectionBoxs;
class DetectionBoxsDefaultTypeInternal;
extern DetectionBoxsDefaultTypeInternal _DetectionBoxs_default_instance_;
class LidarImageResult;
class LidarImageResultDefaultTypeInternal;
extern LidarImageResultDefaultTypeInternal _LidarImageResult_default_instance_;
class MaxSafeDistance;
class MaxSafeDistanceDefaultTypeInternal;
extern MaxSafeDistanceDefaultTypeInternal _MaxSafeDistance_default_instance_;
class ObjectsDistance;
class ObjectsDistanceDefaultTypeInternal;
extern ObjectsDistanceDefaultTypeInternal _ObjectsDistance_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class SendResult;
class SendResultDefaultTypeInternal;
extern SendResultDefaultTypeInternal _SendResult_default_instance_;
class SyncCameraResult;
class SyncCameraResultDefaultTypeInternal;
extern SyncCameraResultDefaultTypeInternal _SyncCameraResult_default_instance_;
class SyncPerceptionResult;
class SyncPerceptionResultDefaultTypeInternal;
extern SyncPerceptionResultDefaultTypeInternal _SyncPerceptionResult_default_instance_;
class YoloDetectionResult;
class YoloDetectionResultDefaultTypeInternal;
extern YoloDetectionResultDefaultTypeInternal _YoloDetectionResult_default_instance_;
}  // namespace proto
}  // namespace watrix
namespace google {
namespace protobuf {
template<> ::watrix::proto::CameraImage* Arena::CreateMaybeMessage<::watrix::proto::CameraImage>(Arena*);
template<> ::watrix::proto::CameraImages* Arena::CreateMaybeMessage<::watrix::proto::CameraImages>(Arena*);
template<> ::watrix::proto::DetectionBox* Arena::CreateMaybeMessage<::watrix::proto::DetectionBox>(Arena*);
template<> ::watrix::proto::DetectionBoxs* Arena::CreateMaybeMessage<::watrix::proto::DetectionBoxs>(Arena*);
template<> ::watrix::proto::LidarImageResult* Arena::CreateMaybeMessage<::watrix::proto::LidarImageResult>(Arena*);
template<> ::watrix::proto::MaxSafeDistance* Arena::CreateMaybeMessage<::watrix::proto::MaxSafeDistance>(Arena*);
template<> ::watrix::proto::ObjectsDistance* Arena::CreateMaybeMessage<::watrix::proto::ObjectsDistance>(Arena*);
template<> ::watrix::proto::Point* Arena::CreateMaybeMessage<::watrix::proto::Point>(Arena*);
template<> ::watrix::proto::SendResult* Arena::CreateMaybeMessage<::watrix::proto::SendResult>(Arena*);
template<> ::watrix::proto::SyncCameraResult* Arena::CreateMaybeMessage<::watrix::proto::SyncCameraResult>(Arena*);
template<> ::watrix::proto::SyncPerceptionResult* Arena::CreateMaybeMessage<::watrix::proto::SyncPerceptionResult>(Arena*);
template<> ::watrix::proto::YoloDetectionResult* Arena::CreateMaybeMessage<::watrix::proto::YoloDetectionResult>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace watrix {
namespace proto {

enum CameraImage_ImageType {
  CameraImage_ImageType_ORIGIN = 0,
  CameraImage_ImageType_MASK_RESULT = 1,
  CameraImage_ImageType_YOLO_DETECT_RESULT = 2
};
bool CameraImage_ImageType_IsValid(int value);
const CameraImage_ImageType CameraImage_ImageType_ImageType_MIN = CameraImage_ImageType_ORIGIN;
const CameraImage_ImageType CameraImage_ImageType_ImageType_MAX = CameraImage_ImageType_YOLO_DETECT_RESULT;
const int CameraImage_ImageType_ImageType_ARRAYSIZE = CameraImage_ImageType_ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraImage_ImageType_descriptor();
inline const ::std::string& CameraImage_ImageType_Name(CameraImage_ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraImage_ImageType_descriptor(), value);
}
inline bool CameraImage_ImageType_Parse(
    const ::std::string& name, CameraImage_ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraImage_ImageType>(
    CameraImage_ImageType_descriptor(), name, value);
}
// ===================================================================

class CameraImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.CameraImage) */ {
 public:
  CameraImage();
  virtual ~CameraImage();

  CameraImage(const CameraImage& from);

  inline CameraImage& operator=(const CameraImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraImage(CameraImage&& from) noexcept
    : CameraImage() {
    *this = ::std::move(from);
  }

  inline CameraImage& operator=(CameraImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraImage* internal_default_instance() {
    return reinterpret_cast<const CameraImage*>(
               &_CameraImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CameraImage* other);
  friend void swap(CameraImage& a, CameraImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraImage* New() const final {
    return CreateMaybeMessage<CameraImage>(NULL);
  }

  CameraImage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraImage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraImage& from);
  void MergeFrom(const CameraImage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CameraImage_ImageType ImageType;
  static const ImageType ORIGIN =
    CameraImage_ImageType_ORIGIN;
  static const ImageType MASK_RESULT =
    CameraImage_ImageType_MASK_RESULT;
  static const ImageType YOLO_DETECT_RESULT =
    CameraImage_ImageType_YOLO_DETECT_RESULT;
  static inline bool ImageType_IsValid(int value) {
    return CameraImage_ImageType_IsValid(value);
  }
  static const ImageType ImageType_MIN =
    CameraImage_ImageType_ImageType_MIN;
  static const ImageType ImageType_MAX =
    CameraImage_ImageType_ImageType_MAX;
  static const int ImageType_ARRAYSIZE =
    CameraImage_ImageType_ImageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageType_descriptor() {
    return CameraImage_ImageType_descriptor();
  }
  static inline const ::std::string& ImageType_Name(ImageType value) {
    return CameraImage_ImageType_Name(value);
  }
  static inline bool ImageType_Parse(const ::std::string& name,
      ImageType* value) {
    return CameraImage_ImageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional uint32 camera_id = 1;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  ::google::protobuf::uint32 camera_id() const;
  void set_camera_id(::google::protobuf::uint32 value);

  // optional uint32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional uint32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional uint32 channel = 4;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 4;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional uint64 timestamp_msec = 7;
  bool has_timestamp_msec() const;
  void clear_timestamp_msec();
  static const int kTimestampMsecFieldNumber = 7;
  ::google::protobuf::uint64 timestamp_msec() const;
  void set_timestamp_msec(::google::protobuf::uint64 value);

  // optional .watrix.proto.CameraImage.ImageType type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::watrix::proto::CameraImage_ImageType type() const;
  void set_type(::watrix::proto::CameraImage_ImageType value);

  // optional int32 interval_time = 9;
  bool has_interval_time() const;
  void clear_interval_time();
  static const int kIntervalTimeFieldNumber = 9;
  ::google::protobuf::int32 interval_time() const;
  void set_interval_time(::google::protobuf::int32 value);

  // optional uint64 frame_count = 8;
  bool has_frame_count() const;
  void clear_frame_count();
  static const int kFrameCountFieldNumber = 8;
  ::google::protobuf::uint64 frame_count() const;
  void set_frame_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:watrix.proto.CameraImage)
 private:
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_height();
  void clear_has_height();
  void set_has_width();
  void clear_has_width();
  void set_has_channel();
  void clear_has_channel();
  void set_has_type();
  void clear_has_type();
  void set_has_data();
  void clear_has_data();
  void set_has_timestamp_msec();
  void clear_has_timestamp_msec();
  void set_has_frame_count();
  void clear_has_frame_count();
  void set_has_interval_time();
  void clear_has_interval_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 camera_id_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint64 timestamp_msec_;
  int type_;
  ::google::protobuf::int32 interval_time_;
  ::google::protobuf::uint64 frame_count_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:watrix.proto.Point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DetectionBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.DetectionBox) */ {
 public:
  DetectionBox();
  virtual ~DetectionBox();

  DetectionBox(const DetectionBox& from);

  inline DetectionBox& operator=(const DetectionBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectionBox(DetectionBox&& from) noexcept
    : DetectionBox() {
    *this = ::std::move(from);
  }

  inline DetectionBox& operator=(DetectionBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectionBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectionBox* internal_default_instance() {
    return reinterpret_cast<const DetectionBox*>(
               &_DetectionBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DetectionBox* other);
  friend void swap(DetectionBox& a, DetectionBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectionBox* New() const final {
    return CreateMaybeMessage<DetectionBox>(NULL);
  }

  DetectionBox* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DetectionBox>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DetectionBox& from);
  void MergeFrom(const DetectionBox& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes class_name = 7;
  bool has_class_name() const;
  void clear_class_name();
  static const int kClassNameFieldNumber = 7;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const void* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // optional .watrix.proto.Point distance = 8;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 8;
  private:
  const ::watrix::proto::Point& _internal_distance() const;
  public:
  const ::watrix::proto::Point& distance() const;
  ::watrix::proto::Point* release_distance();
  ::watrix::proto::Point* mutable_distance();
  void set_allocated_distance(::watrix::proto::Point* distance);

  // optional uint32 xmin = 1;
  bool has_xmin() const;
  void clear_xmin();
  static const int kXminFieldNumber = 1;
  ::google::protobuf::uint32 xmin() const;
  void set_xmin(::google::protobuf::uint32 value);

  // optional uint32 ymin = 2;
  bool has_ymin() const;
  void clear_ymin();
  static const int kYminFieldNumber = 2;
  ::google::protobuf::uint32 ymin() const;
  void set_ymin(::google::protobuf::uint32 value);

  // optional uint32 xmax = 3;
  bool has_xmax() const;
  void clear_xmax();
  static const int kXmaxFieldNumber = 3;
  ::google::protobuf::uint32 xmax() const;
  void set_xmax(::google::protobuf::uint32 value);

  // optional uint32 ymax = 4;
  bool has_ymax() const;
  void clear_ymax();
  static const int kYmaxFieldNumber = 4;
  ::google::protobuf::uint32 ymax() const;
  void set_ymax(::google::protobuf::uint32 value);

  // optional float confidence = 5;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 5;
  float confidence() const;
  void set_confidence(float value);

  // optional uint32 class_index = 6;
  bool has_class_index() const;
  void clear_class_index();
  static const int kClassIndexFieldNumber = 6;
  ::google::protobuf::uint32 class_index() const;
  void set_class_index(::google::protobuf::uint32 value);

  // optional int32 invasion_status = 9;
  bool has_invasion_status() const;
  void clear_invasion_status();
  static const int kInvasionStatusFieldNumber = 9;
  ::google::protobuf::int32 invasion_status() const;
  void set_invasion_status(::google::protobuf::int32 value);

  // optional float invasion_distance = 10;
  bool has_invasion_distance() const;
  void clear_invasion_distance();
  static const int kInvasionDistanceFieldNumber = 10;
  float invasion_distance() const;
  void set_invasion_distance(float value);

  // @@protoc_insertion_point(class_scope:watrix.proto.DetectionBox)
 private:
  void set_has_xmin();
  void clear_has_xmin();
  void set_has_ymin();
  void clear_has_ymin();
  void set_has_xmax();
  void clear_has_xmax();
  void set_has_ymax();
  void clear_has_ymax();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_class_index();
  void clear_has_class_index();
  void set_has_class_name();
  void clear_has_class_name();
  void set_has_distance();
  void clear_has_distance();
  void set_has_invasion_status();
  void clear_has_invasion_status();
  void set_has_invasion_distance();
  void clear_has_invasion_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::watrix::proto::Point* distance_;
  ::google::protobuf::uint32 xmin_;
  ::google::protobuf::uint32 ymin_;
  ::google::protobuf::uint32 xmax_;
  ::google::protobuf::uint32 ymax_;
  float confidence_;
  ::google::protobuf::uint32 class_index_;
  ::google::protobuf::int32 invasion_status_;
  float invasion_distance_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DetectionBoxs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.DetectionBoxs) */ {
 public:
  DetectionBoxs();
  virtual ~DetectionBoxs();

  DetectionBoxs(const DetectionBoxs& from);

  inline DetectionBoxs& operator=(const DetectionBoxs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectionBoxs(DetectionBoxs&& from) noexcept
    : DetectionBoxs() {
    *this = ::std::move(from);
  }

  inline DetectionBoxs& operator=(DetectionBoxs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectionBoxs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectionBoxs* internal_default_instance() {
    return reinterpret_cast<const DetectionBoxs*>(
               &_DetectionBoxs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DetectionBoxs* other);
  friend void swap(DetectionBoxs& a, DetectionBoxs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectionBoxs* New() const final {
    return CreateMaybeMessage<DetectionBoxs>(NULL);
  }

  DetectionBoxs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DetectionBoxs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DetectionBoxs& from);
  void MergeFrom(const DetectionBoxs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionBoxs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .watrix.proto.DetectionBox boxs = 1;
  int boxs_size() const;
  void clear_boxs();
  static const int kBoxsFieldNumber = 1;
  ::watrix::proto::DetectionBox* mutable_boxs(int index);
  ::google::protobuf::RepeatedPtrField< ::watrix::proto::DetectionBox >*
      mutable_boxs();
  const ::watrix::proto::DetectionBox& boxs(int index) const;
  ::watrix::proto::DetectionBox* add_boxs();
  const ::google::protobuf::RepeatedPtrField< ::watrix::proto::DetectionBox >&
      boxs() const;

  // @@protoc_insertion_point(class_scope:watrix.proto.DetectionBoxs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::watrix::proto::DetectionBox > boxs_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectsDistance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.ObjectsDistance) */ {
 public:
  ObjectsDistance();
  virtual ~ObjectsDistance();

  ObjectsDistance(const ObjectsDistance& from);

  inline ObjectsDistance& operator=(const ObjectsDistance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectsDistance(ObjectsDistance&& from) noexcept
    : ObjectsDistance() {
    *this = ::std::move(from);
  }

  inline ObjectsDistance& operator=(ObjectsDistance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectsDistance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectsDistance* internal_default_instance() {
    return reinterpret_cast<const ObjectsDistance*>(
               &_ObjectsDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ObjectsDistance* other);
  friend void swap(ObjectsDistance& a, ObjectsDistance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectsDistance* New() const final {
    return CreateMaybeMessage<ObjectsDistance>(NULL);
  }

  ObjectsDistance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectsDistance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectsDistance& from);
  void MergeFrom(const ObjectsDistance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectsDistance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 object_distance = 1;
  bool has_object_distance() const;
  void clear_object_distance();
  static const int kObjectDistanceFieldNumber = 1;
  ::google::protobuf::int32 object_distance() const;
  void set_object_distance(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:watrix.proto.ObjectsDistance)
 private:
  void set_has_object_distance();
  void clear_has_object_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 object_distance_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraImages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.CameraImages) */ {
 public:
  CameraImages();
  virtual ~CameraImages();

  CameraImages(const CameraImages& from);

  inline CameraImages& operator=(const CameraImages& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraImages(CameraImages&& from) noexcept
    : CameraImages() {
    *this = ::std::move(from);
  }

  inline CameraImages& operator=(CameraImages&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraImages& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraImages* internal_default_instance() {
    return reinterpret_cast<const CameraImages*>(
               &_CameraImages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CameraImages* other);
  friend void swap(CameraImages& a, CameraImages& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraImages* New() const final {
    return CreateMaybeMessage<CameraImages>(NULL);
  }

  CameraImages* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraImages>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraImages& from);
  void MergeFrom(const CameraImages& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraImages* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .watrix.proto.CameraImage images = 1;
  int images_size() const;
  void clear_images();
  static const int kImagesFieldNumber = 1;
  ::watrix::proto::CameraImage* mutable_images(int index);
  ::google::protobuf::RepeatedPtrField< ::watrix::proto::CameraImage >*
      mutable_images();
  const ::watrix::proto::CameraImage& images(int index) const;
  ::watrix::proto::CameraImage* add_images();
  const ::google::protobuf::RepeatedPtrField< ::watrix::proto::CameraImage >&
      images() const;

  // @@protoc_insertion_point(class_scope:watrix.proto.CameraImages)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::watrix::proto::CameraImage > images_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YoloDetectionResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.YoloDetectionResult) */ {
 public:
  YoloDetectionResult();
  virtual ~YoloDetectionResult();

  YoloDetectionResult(const YoloDetectionResult& from);

  inline YoloDetectionResult& operator=(const YoloDetectionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YoloDetectionResult(YoloDetectionResult&& from) noexcept
    : YoloDetectionResult() {
    *this = ::std::move(from);
  }

  inline YoloDetectionResult& operator=(YoloDetectionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YoloDetectionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YoloDetectionResult* internal_default_instance() {
    return reinterpret_cast<const YoloDetectionResult*>(
               &_YoloDetectionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(YoloDetectionResult* other);
  friend void swap(YoloDetectionResult& a, YoloDetectionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YoloDetectionResult* New() const final {
    return CreateMaybeMessage<YoloDetectionResult>(NULL);
  }

  YoloDetectionResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<YoloDetectionResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const YoloDetectionResult& from);
  void MergeFrom(const YoloDetectionResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YoloDetectionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .watrix.proto.CameraImage source_image = 1;
  bool has_source_image() const;
  void clear_source_image();
  static const int kSourceImageFieldNumber = 1;
  private:
  const ::watrix::proto::CameraImage& _internal_source_image() const;
  public:
  const ::watrix::proto::CameraImage& source_image() const;
  ::watrix::proto::CameraImage* release_source_image();
  ::watrix::proto::CameraImage* mutable_source_image();
  void set_allocated_source_image(::watrix::proto::CameraImage* source_image);

  // optional .watrix.proto.DetectionBoxs detection_boxs = 2;
  bool has_detection_boxs() const;
  void clear_detection_boxs();
  static const int kDetectionBoxsFieldNumber = 2;
  private:
  const ::watrix::proto::DetectionBoxs& _internal_detection_boxs() const;
  public:
  const ::watrix::proto::DetectionBoxs& detection_boxs() const;
  ::watrix::proto::DetectionBoxs* release_detection_boxs();
  ::watrix::proto::DetectionBoxs* mutable_detection_boxs();
  void set_allocated_detection_boxs(::watrix::proto::DetectionBoxs* detection_boxs);

  // @@protoc_insertion_point(class_scope:watrix.proto.YoloDetectionResult)
 private:
  void set_has_source_image();
  void clear_has_source_image();
  void set_has_detection_boxs();
  void clear_has_detection_boxs();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::watrix::proto::CameraImage* source_image_;
  ::watrix::proto::DetectionBoxs* detection_boxs_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LidarImageResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.LidarImageResult) */ {
 public:
  LidarImageResult();
  virtual ~LidarImageResult();

  LidarImageResult(const LidarImageResult& from);

  inline LidarImageResult& operator=(const LidarImageResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarImageResult(LidarImageResult&& from) noexcept
    : LidarImageResult() {
    *this = ::std::move(from);
  }

  inline LidarImageResult& operator=(LidarImageResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarImageResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarImageResult* internal_default_instance() {
    return reinterpret_cast<const LidarImageResult*>(
               &_LidarImageResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(LidarImageResult* other);
  friend void swap(LidarImageResult& a, LidarImageResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarImageResult* New() const final {
    return CreateMaybeMessage<LidarImageResult>(NULL);
  }

  LidarImageResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LidarImageResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LidarImageResult& from);
  void MergeFrom(const LidarImageResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarImageResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .watrix.proto.CameraImage lidar_image = 1;
  bool has_lidar_image() const;
  void clear_lidar_image();
  static const int kLidarImageFieldNumber = 1;
  private:
  const ::watrix::proto::CameraImage& _internal_lidar_image() const;
  public:
  const ::watrix::proto::CameraImage& lidar_image() const;
  ::watrix::proto::CameraImage* release_lidar_image();
  ::watrix::proto::CameraImage* mutable_lidar_image();
  void set_allocated_lidar_image(::watrix::proto::CameraImage* lidar_image);

  // optional uint64 timestamp_msec = 2;
  bool has_timestamp_msec() const;
  void clear_timestamp_msec();
  static const int kTimestampMsecFieldNumber = 2;
  ::google::protobuf::uint64 timestamp_msec() const;
  void set_timestamp_msec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:watrix.proto.LidarImageResult)
 private:
  void set_has_lidar_image();
  void clear_has_lidar_image();
  void set_has_timestamp_msec();
  void clear_has_timestamp_msec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::watrix::proto::CameraImage* lidar_image_;
  ::google::protobuf::uint64 timestamp_msec_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SyncCameraResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.SyncCameraResult) */ {
 public:
  SyncCameraResult();
  virtual ~SyncCameraResult();

  SyncCameraResult(const SyncCameraResult& from);

  inline SyncCameraResult& operator=(const SyncCameraResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncCameraResult(SyncCameraResult&& from) noexcept
    : SyncCameraResult() {
    *this = ::std::move(from);
  }

  inline SyncCameraResult& operator=(SyncCameraResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncCameraResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncCameraResult* internal_default_instance() {
    return reinterpret_cast<const SyncCameraResult*>(
               &_SyncCameraResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SyncCameraResult* other);
  friend void swap(SyncCameraResult& a, SyncCameraResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncCameraResult* New() const final {
    return CreateMaybeMessage<SyncCameraResult>(NULL);
  }

  SyncCameraResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyncCameraResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyncCameraResult& from);
  void MergeFrom(const SyncCameraResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncCameraResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .watrix.proto.CameraImages sync_images = 1;
  bool has_sync_images() const;
  void clear_sync_images();
  static const int kSyncImagesFieldNumber = 1;
  private:
  const ::watrix::proto::CameraImages& _internal_sync_images() const;
  public:
  const ::watrix::proto::CameraImages& sync_images() const;
  ::watrix::proto::CameraImages* release_sync_images();
  ::watrix::proto::CameraImages* mutable_sync_images();
  void set_allocated_sync_images(::watrix::proto::CameraImages* sync_images);

  // optional uint64 timestamp_msec = 2;
  bool has_timestamp_msec() const;
  void clear_timestamp_msec();
  static const int kTimestampMsecFieldNumber = 2;
  ::google::protobuf::uint64 timestamp_msec() const;
  void set_timestamp_msec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:watrix.proto.SyncCameraResult)
 private:
  void set_has_sync_images();
  void clear_has_sync_images();
  void set_has_timestamp_msec();
  void clear_has_timestamp_msec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::watrix::proto::CameraImages* sync_images_;
  ::google::protobuf::uint64 timestamp_msec_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MaxSafeDistance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.MaxSafeDistance) */ {
 public:
  MaxSafeDistance();
  virtual ~MaxSafeDistance();

  MaxSafeDistance(const MaxSafeDistance& from);

  inline MaxSafeDistance& operator=(const MaxSafeDistance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MaxSafeDistance(MaxSafeDistance&& from) noexcept
    : MaxSafeDistance() {
    *this = ::std::move(from);
  }

  inline MaxSafeDistance& operator=(MaxSafeDistance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaxSafeDistance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaxSafeDistance* internal_default_instance() {
    return reinterpret_cast<const MaxSafeDistance*>(
               &_MaxSafeDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(MaxSafeDistance* other);
  friend void swap(MaxSafeDistance& a, MaxSafeDistance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MaxSafeDistance* New() const final {
    return CreateMaybeMessage<MaxSafeDistance>(NULL);
  }

  MaxSafeDistance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MaxSafeDistance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MaxSafeDistance& from);
  void MergeFrom(const MaxSafeDistance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxSafeDistance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .watrix.proto.ObjectsDistance lidar_distance = 2;
  int lidar_distance_size() const;
  void clear_lidar_distance();
  static const int kLidarDistanceFieldNumber = 2;
  ::watrix::proto::ObjectsDistance* mutable_lidar_distance(int index);
  ::google::protobuf::RepeatedPtrField< ::watrix::proto::ObjectsDistance >*
      mutable_lidar_distance();
  const ::watrix::proto::ObjectsDistance& lidar_distance(int index) const;
  ::watrix::proto::ObjectsDistance* add_lidar_distance();
  const ::google::protobuf::RepeatedPtrField< ::watrix::proto::ObjectsDistance >&
      lidar_distance() const;

  // optional int32 image_distance = 1;
  bool has_image_distance() const;
  void clear_image_distance();
  static const int kImageDistanceFieldNumber = 1;
  ::google::protobuf::int32 image_distance() const;
  void set_image_distance(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:watrix.proto.MaxSafeDistance)
 private:
  void set_has_image_distance();
  void clear_has_image_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::watrix::proto::ObjectsDistance > lidar_distance_;
  ::google::protobuf::int32 image_distance_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.SendResult) */ {
 public:
  SendResult();
  virtual ~SendResult();

  SendResult(const SendResult& from);

  inline SendResult& operator=(const SendResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendResult(SendResult&& from) noexcept
    : SendResult() {
    *this = ::std::move(from);
  }

  inline SendResult& operator=(SendResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendResult* internal_default_instance() {
    return reinterpret_cast<const SendResult*>(
               &_SendResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SendResult* other);
  friend void swap(SendResult& a, SendResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendResult* New() const final {
    return CreateMaybeMessage<SendResult>(NULL);
  }

  SendResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendResult& from);
  void MergeFrom(const SendResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .watrix.proto.CameraImage source_image = 1;
  bool has_source_image() const;
  void clear_source_image();
  static const int kSourceImageFieldNumber = 1;
  private:
  const ::watrix::proto::CameraImage& _internal_source_image() const;
  public:
  const ::watrix::proto::CameraImage& source_image() const;
  ::watrix::proto::CameraImage* release_source_image();
  ::watrix::proto::CameraImage* mutable_source_image();
  void set_allocated_source_image(::watrix::proto::CameraImage* source_image);

  // optional .watrix.proto.CameraImage seg_binary_mask = 2;
  bool has_seg_binary_mask() const;
  void clear_seg_binary_mask();
  static const int kSegBinaryMaskFieldNumber = 2;
  private:
  const ::watrix::proto::CameraImage& _internal_seg_binary_mask() const;
  public:
  const ::watrix::proto::CameraImage& seg_binary_mask() const;
  ::watrix::proto::CameraImage* release_seg_binary_mask();
  ::watrix::proto::CameraImage* mutable_seg_binary_mask();
  void set_allocated_seg_binary_mask(::watrix::proto::CameraImage* seg_binary_mask);

  // optional .watrix.proto.DetectionBoxs detection_boxs = 3;
  bool has_detection_boxs() const;
  void clear_detection_boxs();
  static const int kDetectionBoxsFieldNumber = 3;
  private:
  const ::watrix::proto::DetectionBoxs& _internal_detection_boxs() const;
  public:
  const ::watrix::proto::DetectionBoxs& detection_boxs() const;
  ::watrix::proto::DetectionBoxs* release_detection_boxs();
  ::watrix::proto::DetectionBoxs* mutable_detection_boxs();
  void set_allocated_detection_boxs(::watrix::proto::DetectionBoxs* detection_boxs);

  // optional .watrix.proto.MaxSafeDistance max_safe_distance = 4;
  bool has_max_safe_distance() const;
  void clear_max_safe_distance();
  static const int kMaxSafeDistanceFieldNumber = 4;
  private:
  const ::watrix::proto::MaxSafeDistance& _internal_max_safe_distance() const;
  public:
  const ::watrix::proto::MaxSafeDistance& max_safe_distance() const;
  ::watrix::proto::MaxSafeDistance* release_max_safe_distance();
  ::watrix::proto::MaxSafeDistance* mutable_max_safe_distance();
  void set_allocated_max_safe_distance(::watrix::proto::MaxSafeDistance* max_safe_distance);

  // @@protoc_insertion_point(class_scope:watrix.proto.SendResult)
 private:
  void set_has_source_image();
  void clear_has_source_image();
  void set_has_seg_binary_mask();
  void clear_has_seg_binary_mask();
  void set_has_detection_boxs();
  void clear_has_detection_boxs();
  void set_has_max_safe_distance();
  void clear_has_max_safe_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::watrix::proto::CameraImage* source_image_;
  ::watrix::proto::CameraImage* seg_binary_mask_;
  ::watrix::proto::DetectionBoxs* detection_boxs_;
  ::watrix::proto::MaxSafeDistance* max_safe_distance_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SyncPerceptionResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:watrix.proto.SyncPerceptionResult) */ {
 public:
  SyncPerceptionResult();
  virtual ~SyncPerceptionResult();

  SyncPerceptionResult(const SyncPerceptionResult& from);

  inline SyncPerceptionResult& operator=(const SyncPerceptionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncPerceptionResult(SyncPerceptionResult&& from) noexcept
    : SyncPerceptionResult() {
    *this = ::std::move(from);
  }

  inline SyncPerceptionResult& operator=(SyncPerceptionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncPerceptionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncPerceptionResult* internal_default_instance() {
    return reinterpret_cast<const SyncPerceptionResult*>(
               &_SyncPerceptionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SyncPerceptionResult* other);
  friend void swap(SyncPerceptionResult& a, SyncPerceptionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncPerceptionResult* New() const final {
    return CreateMaybeMessage<SyncPerceptionResult>(NULL);
  }

  SyncPerceptionResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyncPerceptionResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyncPerceptionResult& from);
  void MergeFrom(const SyncPerceptionResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncPerceptionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .watrix.proto.CameraImages source_images = 1;
  bool has_source_images() const;
  void clear_source_images();
  static const int kSourceImagesFieldNumber = 1;
  private:
  const ::watrix::proto::CameraImages& _internal_source_images() const;
  public:
  const ::watrix::proto::CameraImages& source_images() const;
  ::watrix::proto::CameraImages* release_source_images();
  ::watrix::proto::CameraImages* mutable_source_images();
  void set_allocated_source_images(::watrix::proto::CameraImages* source_images);

  // optional .watrix.proto.CameraImages lane_binary_masks = 2;
  bool has_lane_binary_masks() const;
  void clear_lane_binary_masks();
  static const int kLaneBinaryMasksFieldNumber = 2;
  private:
  const ::watrix::proto::CameraImages& _internal_lane_binary_masks() const;
  public:
  const ::watrix::proto::CameraImages& lane_binary_masks() const;
  ::watrix::proto::CameraImages* release_lane_binary_masks();
  ::watrix::proto::CameraImages* mutable_lane_binary_masks();
  void set_allocated_lane_binary_masks(::watrix::proto::CameraImages* lane_binary_masks);

  // optional .watrix.proto.DetectionBoxs detection_boxs1 = 3;
  bool has_detection_boxs1() const;
  void clear_detection_boxs1();
  static const int kDetectionBoxs1FieldNumber = 3;
  private:
  const ::watrix::proto::DetectionBoxs& _internal_detection_boxs1() const;
  public:
  const ::watrix::proto::DetectionBoxs& detection_boxs1() const;
  ::watrix::proto::DetectionBoxs* release_detection_boxs1();
  ::watrix::proto::DetectionBoxs* mutable_detection_boxs1();
  void set_allocated_detection_boxs1(::watrix::proto::DetectionBoxs* detection_boxs1);

  // optional .watrix.proto.DetectionBoxs detection_boxs2 = 4;
  bool has_detection_boxs2() const;
  void clear_detection_boxs2();
  static const int kDetectionBoxs2FieldNumber = 4;
  private:
  const ::watrix::proto::DetectionBoxs& _internal_detection_boxs2() const;
  public:
  const ::watrix::proto::DetectionBoxs& detection_boxs2() const;
  ::watrix::proto::DetectionBoxs* release_detection_boxs2();
  ::watrix::proto::DetectionBoxs* mutable_detection_boxs2();
  void set_allocated_detection_boxs2(::watrix::proto::DetectionBoxs* detection_boxs2);

  // optional .watrix.proto.MaxSafeDistance max_safe_distance = 5;
  bool has_max_safe_distance() const;
  void clear_max_safe_distance();
  static const int kMaxSafeDistanceFieldNumber = 5;
  private:
  const ::watrix::proto::MaxSafeDistance& _internal_max_safe_distance() const;
  public:
  const ::watrix::proto::MaxSafeDistance& max_safe_distance() const;
  ::watrix::proto::MaxSafeDistance* release_max_safe_distance();
  ::watrix::proto::MaxSafeDistance* mutable_max_safe_distance();
  void set_allocated_max_safe_distance(::watrix::proto::MaxSafeDistance* max_safe_distance);

  // @@protoc_insertion_point(class_scope:watrix.proto.SyncPerceptionResult)
 private:
  void set_has_source_images();
  void clear_has_source_images();
  void set_has_lane_binary_masks();
  void clear_has_lane_binary_masks();
  void set_has_detection_boxs1();
  void clear_has_detection_boxs1();
  void set_has_detection_boxs2();
  void clear_has_detection_boxs2();
  void set_has_max_safe_distance();
  void clear_has_max_safe_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::watrix::proto::CameraImages* source_images_;
  ::watrix::proto::CameraImages* lane_binary_masks_;
  ::watrix::proto::DetectionBoxs* detection_boxs1_;
  ::watrix::proto::DetectionBoxs* detection_boxs2_;
  ::watrix::proto::MaxSafeDistance* max_safe_distance_;
  friend struct ::protobuf_camera_5fimage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CameraImage

// optional uint32 camera_id = 1;
inline bool CameraImage::has_camera_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraImage::set_has_camera_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraImage::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraImage::clear_camera_id() {
  camera_id_ = 0u;
  clear_has_camera_id();
}
inline ::google::protobuf::uint32 CameraImage::camera_id() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.camera_id)
  return camera_id_;
}
inline void CameraImage::set_camera_id(::google::protobuf::uint32 value) {
  set_has_camera_id();
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.camera_id)
}

// optional uint32 height = 2;
inline bool CameraImage::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraImage::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraImage::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraImage::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 CameraImage::height() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.height)
  return height_;
}
inline void CameraImage::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.height)
}

// optional uint32 width = 3;
inline bool CameraImage::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraImage::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraImage::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraImage::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 CameraImage::width() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.width)
  return width_;
}
inline void CameraImage::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.width)
}

// optional uint32 channel = 4;
inline bool CameraImage::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraImage::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraImage::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraImage::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CameraImage::channel() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.channel)
  return channel_;
}
inline void CameraImage::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.channel)
}

// optional .watrix.proto.CameraImage.ImageType type = 5;
inline bool CameraImage::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CameraImage::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CameraImage::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CameraImage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::watrix::proto::CameraImage_ImageType CameraImage::type() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.type)
  return static_cast< ::watrix::proto::CameraImage_ImageType >(type_);
}
inline void CameraImage::set_type(::watrix::proto::CameraImage_ImageType value) {
  assert(::watrix::proto::CameraImage_ImageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.type)
}

// optional bytes data = 6;
inline bool CameraImage::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraImage::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraImage::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraImage::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CameraImage::data() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.data)
  return data_.GetNoArena();
}
inline void CameraImage::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.data)
}
#if LANG_CXX11
inline void CameraImage::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:watrix.proto.CameraImage.data)
}
#endif
inline void CameraImage::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:watrix.proto.CameraImage.data)
}
inline void CameraImage::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:watrix.proto.CameraImage.data)
}
inline ::std::string* CameraImage::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:watrix.proto.CameraImage.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraImage::release_data() {
  // @@protoc_insertion_point(field_release:watrix.proto.CameraImage.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraImage::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.CameraImage.data)
}

// optional uint64 timestamp_msec = 7;
inline bool CameraImage::has_timestamp_msec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CameraImage::set_has_timestamp_msec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CameraImage::clear_has_timestamp_msec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CameraImage::clear_timestamp_msec() {
  timestamp_msec_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_msec();
}
inline ::google::protobuf::uint64 CameraImage::timestamp_msec() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.timestamp_msec)
  return timestamp_msec_;
}
inline void CameraImage::set_timestamp_msec(::google::protobuf::uint64 value) {
  set_has_timestamp_msec();
  timestamp_msec_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.timestamp_msec)
}

// optional uint64 frame_count = 8;
inline bool CameraImage::has_frame_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CameraImage::set_has_frame_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CameraImage::clear_has_frame_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CameraImage::clear_frame_count() {
  frame_count_ = GOOGLE_ULONGLONG(0);
  clear_has_frame_count();
}
inline ::google::protobuf::uint64 CameraImage::frame_count() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.frame_count)
  return frame_count_;
}
inline void CameraImage::set_frame_count(::google::protobuf::uint64 value) {
  set_has_frame_count();
  frame_count_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.frame_count)
}

// optional int32 interval_time = 9;
inline bool CameraImage::has_interval_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CameraImage::set_has_interval_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CameraImage::clear_has_interval_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CameraImage::clear_interval_time() {
  interval_time_ = 0;
  clear_has_interval_time();
}
inline ::google::protobuf::int32 CameraImage::interval_time() const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImage.interval_time)
  return interval_time_;
}
inline void CameraImage::set_interval_time(::google::protobuf::int32 value) {
  set_has_interval_time();
  interval_time_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.CameraImage.interval_time)
}

// -------------------------------------------------------------------

// Point

// optional double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:watrix.proto.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.Point.x)
}

// optional double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:watrix.proto.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.Point.y)
}

// optional double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:watrix.proto.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.Point.z)
}

// -------------------------------------------------------------------

// DetectionBox

// optional uint32 xmin = 1;
inline bool DetectionBox::has_xmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectionBox::set_has_xmin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectionBox::clear_has_xmin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectionBox::clear_xmin() {
  xmin_ = 0u;
  clear_has_xmin();
}
inline ::google::protobuf::uint32 DetectionBox::xmin() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.xmin)
  return xmin_;
}
inline void DetectionBox::set_xmin(::google::protobuf::uint32 value) {
  set_has_xmin();
  xmin_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.xmin)
}

// optional uint32 ymin = 2;
inline bool DetectionBox::has_ymin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetectionBox::set_has_ymin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetectionBox::clear_has_ymin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetectionBox::clear_ymin() {
  ymin_ = 0u;
  clear_has_ymin();
}
inline ::google::protobuf::uint32 DetectionBox::ymin() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.ymin)
  return ymin_;
}
inline void DetectionBox::set_ymin(::google::protobuf::uint32 value) {
  set_has_ymin();
  ymin_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.ymin)
}

// optional uint32 xmax = 3;
inline bool DetectionBox::has_xmax() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetectionBox::set_has_xmax() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetectionBox::clear_has_xmax() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetectionBox::clear_xmax() {
  xmax_ = 0u;
  clear_has_xmax();
}
inline ::google::protobuf::uint32 DetectionBox::xmax() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.xmax)
  return xmax_;
}
inline void DetectionBox::set_xmax(::google::protobuf::uint32 value) {
  set_has_xmax();
  xmax_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.xmax)
}

// optional uint32 ymax = 4;
inline bool DetectionBox::has_ymax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetectionBox::set_has_ymax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetectionBox::clear_has_ymax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetectionBox::clear_ymax() {
  ymax_ = 0u;
  clear_has_ymax();
}
inline ::google::protobuf::uint32 DetectionBox::ymax() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.ymax)
  return ymax_;
}
inline void DetectionBox::set_ymax(::google::protobuf::uint32 value) {
  set_has_ymax();
  ymax_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.ymax)
}

// optional float confidence = 5;
inline bool DetectionBox::has_confidence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetectionBox::set_has_confidence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetectionBox::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetectionBox::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float DetectionBox::confidence() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.confidence)
  return confidence_;
}
inline void DetectionBox::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.confidence)
}

// optional uint32 class_index = 6;
inline bool DetectionBox::has_class_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DetectionBox::set_has_class_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DetectionBox::clear_has_class_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DetectionBox::clear_class_index() {
  class_index_ = 0u;
  clear_has_class_index();
}
inline ::google::protobuf::uint32 DetectionBox::class_index() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.class_index)
  return class_index_;
}
inline void DetectionBox::set_class_index(::google::protobuf::uint32 value) {
  set_has_class_index();
  class_index_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.class_index)
}

// optional bytes class_name = 7;
inline bool DetectionBox::has_class_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectionBox::set_has_class_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectionBox::clear_has_class_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectionBox::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_class_name();
}
inline const ::std::string& DetectionBox::class_name() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.class_name)
  return class_name_.GetNoArena();
}
inline void DetectionBox::set_class_name(const ::std::string& value) {
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.class_name)
}
#if LANG_CXX11
inline void DetectionBox::set_class_name(::std::string&& value) {
  set_has_class_name();
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:watrix.proto.DetectionBox.class_name)
}
#endif
inline void DetectionBox::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:watrix.proto.DetectionBox.class_name)
}
inline void DetectionBox::set_class_name(const void* value, size_t size) {
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:watrix.proto.DetectionBox.class_name)
}
inline ::std::string* DetectionBox::mutable_class_name() {
  set_has_class_name();
  // @@protoc_insertion_point(field_mutable:watrix.proto.DetectionBox.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetectionBox::release_class_name() {
  // @@protoc_insertion_point(field_release:watrix.proto.DetectionBox.class_name)
  if (!has_class_name()) {
    return NULL;
  }
  clear_has_class_name();
  return class_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetectionBox::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    set_has_class_name();
  } else {
    clear_has_class_name();
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.DetectionBox.class_name)
}

// optional .watrix.proto.Point distance = 8;
inline bool DetectionBox::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectionBox::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectionBox::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectionBox::clear_distance() {
  if (distance_ != NULL) distance_->Clear();
  clear_has_distance();
}
inline const ::watrix::proto::Point& DetectionBox::_internal_distance() const {
  return *distance_;
}
inline const ::watrix::proto::Point& DetectionBox::distance() const {
  const ::watrix::proto::Point* p = distance_;
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.distance)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::Point*>(
      &::watrix::proto::_Point_default_instance_);
}
inline ::watrix::proto::Point* DetectionBox::release_distance() {
  // @@protoc_insertion_point(field_release:watrix.proto.DetectionBox.distance)
  clear_has_distance();
  ::watrix::proto::Point* temp = distance_;
  distance_ = NULL;
  return temp;
}
inline ::watrix::proto::Point* DetectionBox::mutable_distance() {
  set_has_distance();
  if (distance_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::Point>(GetArenaNoVirtual());
    distance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.DetectionBox.distance)
  return distance_;
}
inline void DetectionBox::set_allocated_distance(::watrix::proto::Point* distance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete distance_;
  }
  if (distance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      distance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distance, submessage_arena);
    }
    set_has_distance();
  } else {
    clear_has_distance();
  }
  distance_ = distance;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.DetectionBox.distance)
}

// optional int32 invasion_status = 9;
inline bool DetectionBox::has_invasion_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DetectionBox::set_has_invasion_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DetectionBox::clear_has_invasion_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DetectionBox::clear_invasion_status() {
  invasion_status_ = 0;
  clear_has_invasion_status();
}
inline ::google::protobuf::int32 DetectionBox::invasion_status() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.invasion_status)
  return invasion_status_;
}
inline void DetectionBox::set_invasion_status(::google::protobuf::int32 value) {
  set_has_invasion_status();
  invasion_status_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.invasion_status)
}

// optional float invasion_distance = 10;
inline bool DetectionBox::has_invasion_distance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DetectionBox::set_has_invasion_distance() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DetectionBox::clear_has_invasion_distance() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DetectionBox::clear_invasion_distance() {
  invasion_distance_ = 0;
  clear_has_invasion_distance();
}
inline float DetectionBox::invasion_distance() const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBox.invasion_distance)
  return invasion_distance_;
}
inline void DetectionBox::set_invasion_distance(float value) {
  set_has_invasion_distance();
  invasion_distance_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.DetectionBox.invasion_distance)
}

// -------------------------------------------------------------------

// DetectionBoxs

// repeated .watrix.proto.DetectionBox boxs = 1;
inline int DetectionBoxs::boxs_size() const {
  return boxs_.size();
}
inline void DetectionBoxs::clear_boxs() {
  boxs_.Clear();
}
inline ::watrix::proto::DetectionBox* DetectionBoxs::mutable_boxs(int index) {
  // @@protoc_insertion_point(field_mutable:watrix.proto.DetectionBoxs.boxs)
  return boxs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::watrix::proto::DetectionBox >*
DetectionBoxs::mutable_boxs() {
  // @@protoc_insertion_point(field_mutable_list:watrix.proto.DetectionBoxs.boxs)
  return &boxs_;
}
inline const ::watrix::proto::DetectionBox& DetectionBoxs::boxs(int index) const {
  // @@protoc_insertion_point(field_get:watrix.proto.DetectionBoxs.boxs)
  return boxs_.Get(index);
}
inline ::watrix::proto::DetectionBox* DetectionBoxs::add_boxs() {
  // @@protoc_insertion_point(field_add:watrix.proto.DetectionBoxs.boxs)
  return boxs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::watrix::proto::DetectionBox >&
DetectionBoxs::boxs() const {
  // @@protoc_insertion_point(field_list:watrix.proto.DetectionBoxs.boxs)
  return boxs_;
}

// -------------------------------------------------------------------

// ObjectsDistance

// optional int32 object_distance = 1;
inline bool ObjectsDistance::has_object_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectsDistance::set_has_object_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectsDistance::clear_has_object_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectsDistance::clear_object_distance() {
  object_distance_ = 0;
  clear_has_object_distance();
}
inline ::google::protobuf::int32 ObjectsDistance::object_distance() const {
  // @@protoc_insertion_point(field_get:watrix.proto.ObjectsDistance.object_distance)
  return object_distance_;
}
inline void ObjectsDistance::set_object_distance(::google::protobuf::int32 value) {
  set_has_object_distance();
  object_distance_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.ObjectsDistance.object_distance)
}

// -------------------------------------------------------------------

// CameraImages

// repeated .watrix.proto.CameraImage images = 1;
inline int CameraImages::images_size() const {
  return images_.size();
}
inline void CameraImages::clear_images() {
  images_.Clear();
}
inline ::watrix::proto::CameraImage* CameraImages::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:watrix.proto.CameraImages.images)
  return images_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::watrix::proto::CameraImage >*
CameraImages::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:watrix.proto.CameraImages.images)
  return &images_;
}
inline const ::watrix::proto::CameraImage& CameraImages::images(int index) const {
  // @@protoc_insertion_point(field_get:watrix.proto.CameraImages.images)
  return images_.Get(index);
}
inline ::watrix::proto::CameraImage* CameraImages::add_images() {
  // @@protoc_insertion_point(field_add:watrix.proto.CameraImages.images)
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::watrix::proto::CameraImage >&
CameraImages::images() const {
  // @@protoc_insertion_point(field_list:watrix.proto.CameraImages.images)
  return images_;
}

// -------------------------------------------------------------------

// YoloDetectionResult

// optional .watrix.proto.CameraImage source_image = 1;
inline bool YoloDetectionResult::has_source_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YoloDetectionResult::set_has_source_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YoloDetectionResult::clear_has_source_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YoloDetectionResult::clear_source_image() {
  if (source_image_ != NULL) source_image_->Clear();
  clear_has_source_image();
}
inline const ::watrix::proto::CameraImage& YoloDetectionResult::_internal_source_image() const {
  return *source_image_;
}
inline const ::watrix::proto::CameraImage& YoloDetectionResult::source_image() const {
  const ::watrix::proto::CameraImage* p = source_image_;
  // @@protoc_insertion_point(field_get:watrix.proto.YoloDetectionResult.source_image)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImage*>(
      &::watrix::proto::_CameraImage_default_instance_);
}
inline ::watrix::proto::CameraImage* YoloDetectionResult::release_source_image() {
  // @@protoc_insertion_point(field_release:watrix.proto.YoloDetectionResult.source_image)
  clear_has_source_image();
  ::watrix::proto::CameraImage* temp = source_image_;
  source_image_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImage* YoloDetectionResult::mutable_source_image() {
  set_has_source_image();
  if (source_image_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImage>(GetArenaNoVirtual());
    source_image_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.YoloDetectionResult.source_image)
  return source_image_;
}
inline void YoloDetectionResult::set_allocated_source_image(::watrix::proto::CameraImage* source_image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_image_;
  }
  if (source_image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_image, submessage_arena);
    }
    set_has_source_image();
  } else {
    clear_has_source_image();
  }
  source_image_ = source_image;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.YoloDetectionResult.source_image)
}

// optional .watrix.proto.DetectionBoxs detection_boxs = 2;
inline bool YoloDetectionResult::has_detection_boxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YoloDetectionResult::set_has_detection_boxs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YoloDetectionResult::clear_has_detection_boxs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YoloDetectionResult::clear_detection_boxs() {
  if (detection_boxs_ != NULL) detection_boxs_->Clear();
  clear_has_detection_boxs();
}
inline const ::watrix::proto::DetectionBoxs& YoloDetectionResult::_internal_detection_boxs() const {
  return *detection_boxs_;
}
inline const ::watrix::proto::DetectionBoxs& YoloDetectionResult::detection_boxs() const {
  const ::watrix::proto::DetectionBoxs* p = detection_boxs_;
  // @@protoc_insertion_point(field_get:watrix.proto.YoloDetectionResult.detection_boxs)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::DetectionBoxs*>(
      &::watrix::proto::_DetectionBoxs_default_instance_);
}
inline ::watrix::proto::DetectionBoxs* YoloDetectionResult::release_detection_boxs() {
  // @@protoc_insertion_point(field_release:watrix.proto.YoloDetectionResult.detection_boxs)
  clear_has_detection_boxs();
  ::watrix::proto::DetectionBoxs* temp = detection_boxs_;
  detection_boxs_ = NULL;
  return temp;
}
inline ::watrix::proto::DetectionBoxs* YoloDetectionResult::mutable_detection_boxs() {
  set_has_detection_boxs();
  if (detection_boxs_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::DetectionBoxs>(GetArenaNoVirtual());
    detection_boxs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.YoloDetectionResult.detection_boxs)
  return detection_boxs_;
}
inline void YoloDetectionResult::set_allocated_detection_boxs(::watrix::proto::DetectionBoxs* detection_boxs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete detection_boxs_;
  }
  if (detection_boxs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detection_boxs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_boxs, submessage_arena);
    }
    set_has_detection_boxs();
  } else {
    clear_has_detection_boxs();
  }
  detection_boxs_ = detection_boxs;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.YoloDetectionResult.detection_boxs)
}

// -------------------------------------------------------------------

// LidarImageResult

// optional .watrix.proto.CameraImage lidar_image = 1;
inline bool LidarImageResult::has_lidar_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LidarImageResult::set_has_lidar_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LidarImageResult::clear_has_lidar_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LidarImageResult::clear_lidar_image() {
  if (lidar_image_ != NULL) lidar_image_->Clear();
  clear_has_lidar_image();
}
inline const ::watrix::proto::CameraImage& LidarImageResult::_internal_lidar_image() const {
  return *lidar_image_;
}
inline const ::watrix::proto::CameraImage& LidarImageResult::lidar_image() const {
  const ::watrix::proto::CameraImage* p = lidar_image_;
  // @@protoc_insertion_point(field_get:watrix.proto.LidarImageResult.lidar_image)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImage*>(
      &::watrix::proto::_CameraImage_default_instance_);
}
inline ::watrix::proto::CameraImage* LidarImageResult::release_lidar_image() {
  // @@protoc_insertion_point(field_release:watrix.proto.LidarImageResult.lidar_image)
  clear_has_lidar_image();
  ::watrix::proto::CameraImage* temp = lidar_image_;
  lidar_image_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImage* LidarImageResult::mutable_lidar_image() {
  set_has_lidar_image();
  if (lidar_image_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImage>(GetArenaNoVirtual());
    lidar_image_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.LidarImageResult.lidar_image)
  return lidar_image_;
}
inline void LidarImageResult::set_allocated_lidar_image(::watrix::proto::CameraImage* lidar_image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lidar_image_;
  }
  if (lidar_image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lidar_image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lidar_image, submessage_arena);
    }
    set_has_lidar_image();
  } else {
    clear_has_lidar_image();
  }
  lidar_image_ = lidar_image;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.LidarImageResult.lidar_image)
}

// optional uint64 timestamp_msec = 2;
inline bool LidarImageResult::has_timestamp_msec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LidarImageResult::set_has_timestamp_msec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LidarImageResult::clear_has_timestamp_msec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LidarImageResult::clear_timestamp_msec() {
  timestamp_msec_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_msec();
}
inline ::google::protobuf::uint64 LidarImageResult::timestamp_msec() const {
  // @@protoc_insertion_point(field_get:watrix.proto.LidarImageResult.timestamp_msec)
  return timestamp_msec_;
}
inline void LidarImageResult::set_timestamp_msec(::google::protobuf::uint64 value) {
  set_has_timestamp_msec();
  timestamp_msec_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.LidarImageResult.timestamp_msec)
}

// -------------------------------------------------------------------

// SyncCameraResult

// optional .watrix.proto.CameraImages sync_images = 1;
inline bool SyncCameraResult::has_sync_images() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncCameraResult::set_has_sync_images() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncCameraResult::clear_has_sync_images() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncCameraResult::clear_sync_images() {
  if (sync_images_ != NULL) sync_images_->Clear();
  clear_has_sync_images();
}
inline const ::watrix::proto::CameraImages& SyncCameraResult::_internal_sync_images() const {
  return *sync_images_;
}
inline const ::watrix::proto::CameraImages& SyncCameraResult::sync_images() const {
  const ::watrix::proto::CameraImages* p = sync_images_;
  // @@protoc_insertion_point(field_get:watrix.proto.SyncCameraResult.sync_images)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImages*>(
      &::watrix::proto::_CameraImages_default_instance_);
}
inline ::watrix::proto::CameraImages* SyncCameraResult::release_sync_images() {
  // @@protoc_insertion_point(field_release:watrix.proto.SyncCameraResult.sync_images)
  clear_has_sync_images();
  ::watrix::proto::CameraImages* temp = sync_images_;
  sync_images_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImages* SyncCameraResult::mutable_sync_images() {
  set_has_sync_images();
  if (sync_images_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImages>(GetArenaNoVirtual());
    sync_images_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SyncCameraResult.sync_images)
  return sync_images_;
}
inline void SyncCameraResult::set_allocated_sync_images(::watrix::proto::CameraImages* sync_images) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sync_images_;
  }
  if (sync_images) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sync_images = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sync_images, submessage_arena);
    }
    set_has_sync_images();
  } else {
    clear_has_sync_images();
  }
  sync_images_ = sync_images;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SyncCameraResult.sync_images)
}

// optional uint64 timestamp_msec = 2;
inline bool SyncCameraResult::has_timestamp_msec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncCameraResult::set_has_timestamp_msec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncCameraResult::clear_has_timestamp_msec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncCameraResult::clear_timestamp_msec() {
  timestamp_msec_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_msec();
}
inline ::google::protobuf::uint64 SyncCameraResult::timestamp_msec() const {
  // @@protoc_insertion_point(field_get:watrix.proto.SyncCameraResult.timestamp_msec)
  return timestamp_msec_;
}
inline void SyncCameraResult::set_timestamp_msec(::google::protobuf::uint64 value) {
  set_has_timestamp_msec();
  timestamp_msec_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.SyncCameraResult.timestamp_msec)
}

// -------------------------------------------------------------------

// MaxSafeDistance

// optional int32 image_distance = 1;
inline bool MaxSafeDistance::has_image_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaxSafeDistance::set_has_image_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaxSafeDistance::clear_has_image_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaxSafeDistance::clear_image_distance() {
  image_distance_ = 0;
  clear_has_image_distance();
}
inline ::google::protobuf::int32 MaxSafeDistance::image_distance() const {
  // @@protoc_insertion_point(field_get:watrix.proto.MaxSafeDistance.image_distance)
  return image_distance_;
}
inline void MaxSafeDistance::set_image_distance(::google::protobuf::int32 value) {
  set_has_image_distance();
  image_distance_ = value;
  // @@protoc_insertion_point(field_set:watrix.proto.MaxSafeDistance.image_distance)
}

// repeated .watrix.proto.ObjectsDistance lidar_distance = 2;
inline int MaxSafeDistance::lidar_distance_size() const {
  return lidar_distance_.size();
}
inline void MaxSafeDistance::clear_lidar_distance() {
  lidar_distance_.Clear();
}
inline ::watrix::proto::ObjectsDistance* MaxSafeDistance::mutable_lidar_distance(int index) {
  // @@protoc_insertion_point(field_mutable:watrix.proto.MaxSafeDistance.lidar_distance)
  return lidar_distance_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::watrix::proto::ObjectsDistance >*
MaxSafeDistance::mutable_lidar_distance() {
  // @@protoc_insertion_point(field_mutable_list:watrix.proto.MaxSafeDistance.lidar_distance)
  return &lidar_distance_;
}
inline const ::watrix::proto::ObjectsDistance& MaxSafeDistance::lidar_distance(int index) const {
  // @@protoc_insertion_point(field_get:watrix.proto.MaxSafeDistance.lidar_distance)
  return lidar_distance_.Get(index);
}
inline ::watrix::proto::ObjectsDistance* MaxSafeDistance::add_lidar_distance() {
  // @@protoc_insertion_point(field_add:watrix.proto.MaxSafeDistance.lidar_distance)
  return lidar_distance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::watrix::proto::ObjectsDistance >&
MaxSafeDistance::lidar_distance() const {
  // @@protoc_insertion_point(field_list:watrix.proto.MaxSafeDistance.lidar_distance)
  return lidar_distance_;
}

// -------------------------------------------------------------------

// SendResult

// optional .watrix.proto.CameraImage source_image = 1;
inline bool SendResult::has_source_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendResult::set_has_source_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendResult::clear_has_source_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendResult::clear_source_image() {
  if (source_image_ != NULL) source_image_->Clear();
  clear_has_source_image();
}
inline const ::watrix::proto::CameraImage& SendResult::_internal_source_image() const {
  return *source_image_;
}
inline const ::watrix::proto::CameraImage& SendResult::source_image() const {
  const ::watrix::proto::CameraImage* p = source_image_;
  // @@protoc_insertion_point(field_get:watrix.proto.SendResult.source_image)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImage*>(
      &::watrix::proto::_CameraImage_default_instance_);
}
inline ::watrix::proto::CameraImage* SendResult::release_source_image() {
  // @@protoc_insertion_point(field_release:watrix.proto.SendResult.source_image)
  clear_has_source_image();
  ::watrix::proto::CameraImage* temp = source_image_;
  source_image_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImage* SendResult::mutable_source_image() {
  set_has_source_image();
  if (source_image_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImage>(GetArenaNoVirtual());
    source_image_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SendResult.source_image)
  return source_image_;
}
inline void SendResult::set_allocated_source_image(::watrix::proto::CameraImage* source_image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_image_;
  }
  if (source_image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_image, submessage_arena);
    }
    set_has_source_image();
  } else {
    clear_has_source_image();
  }
  source_image_ = source_image;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SendResult.source_image)
}

// optional .watrix.proto.CameraImage seg_binary_mask = 2;
inline bool SendResult::has_seg_binary_mask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendResult::set_has_seg_binary_mask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendResult::clear_has_seg_binary_mask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendResult::clear_seg_binary_mask() {
  if (seg_binary_mask_ != NULL) seg_binary_mask_->Clear();
  clear_has_seg_binary_mask();
}
inline const ::watrix::proto::CameraImage& SendResult::_internal_seg_binary_mask() const {
  return *seg_binary_mask_;
}
inline const ::watrix::proto::CameraImage& SendResult::seg_binary_mask() const {
  const ::watrix::proto::CameraImage* p = seg_binary_mask_;
  // @@protoc_insertion_point(field_get:watrix.proto.SendResult.seg_binary_mask)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImage*>(
      &::watrix::proto::_CameraImage_default_instance_);
}
inline ::watrix::proto::CameraImage* SendResult::release_seg_binary_mask() {
  // @@protoc_insertion_point(field_release:watrix.proto.SendResult.seg_binary_mask)
  clear_has_seg_binary_mask();
  ::watrix::proto::CameraImage* temp = seg_binary_mask_;
  seg_binary_mask_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImage* SendResult::mutable_seg_binary_mask() {
  set_has_seg_binary_mask();
  if (seg_binary_mask_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImage>(GetArenaNoVirtual());
    seg_binary_mask_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SendResult.seg_binary_mask)
  return seg_binary_mask_;
}
inline void SendResult::set_allocated_seg_binary_mask(::watrix::proto::CameraImage* seg_binary_mask) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete seg_binary_mask_;
  }
  if (seg_binary_mask) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      seg_binary_mask = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, seg_binary_mask, submessage_arena);
    }
    set_has_seg_binary_mask();
  } else {
    clear_has_seg_binary_mask();
  }
  seg_binary_mask_ = seg_binary_mask;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SendResult.seg_binary_mask)
}

// optional .watrix.proto.DetectionBoxs detection_boxs = 3;
inline bool SendResult::has_detection_boxs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendResult::set_has_detection_boxs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendResult::clear_has_detection_boxs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendResult::clear_detection_boxs() {
  if (detection_boxs_ != NULL) detection_boxs_->Clear();
  clear_has_detection_boxs();
}
inline const ::watrix::proto::DetectionBoxs& SendResult::_internal_detection_boxs() const {
  return *detection_boxs_;
}
inline const ::watrix::proto::DetectionBoxs& SendResult::detection_boxs() const {
  const ::watrix::proto::DetectionBoxs* p = detection_boxs_;
  // @@protoc_insertion_point(field_get:watrix.proto.SendResult.detection_boxs)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::DetectionBoxs*>(
      &::watrix::proto::_DetectionBoxs_default_instance_);
}
inline ::watrix::proto::DetectionBoxs* SendResult::release_detection_boxs() {
  // @@protoc_insertion_point(field_release:watrix.proto.SendResult.detection_boxs)
  clear_has_detection_boxs();
  ::watrix::proto::DetectionBoxs* temp = detection_boxs_;
  detection_boxs_ = NULL;
  return temp;
}
inline ::watrix::proto::DetectionBoxs* SendResult::mutable_detection_boxs() {
  set_has_detection_boxs();
  if (detection_boxs_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::DetectionBoxs>(GetArenaNoVirtual());
    detection_boxs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SendResult.detection_boxs)
  return detection_boxs_;
}
inline void SendResult::set_allocated_detection_boxs(::watrix::proto::DetectionBoxs* detection_boxs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete detection_boxs_;
  }
  if (detection_boxs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detection_boxs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_boxs, submessage_arena);
    }
    set_has_detection_boxs();
  } else {
    clear_has_detection_boxs();
  }
  detection_boxs_ = detection_boxs;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SendResult.detection_boxs)
}

// optional .watrix.proto.MaxSafeDistance max_safe_distance = 4;
inline bool SendResult::has_max_safe_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendResult::set_has_max_safe_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendResult::clear_has_max_safe_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendResult::clear_max_safe_distance() {
  if (max_safe_distance_ != NULL) max_safe_distance_->Clear();
  clear_has_max_safe_distance();
}
inline const ::watrix::proto::MaxSafeDistance& SendResult::_internal_max_safe_distance() const {
  return *max_safe_distance_;
}
inline const ::watrix::proto::MaxSafeDistance& SendResult::max_safe_distance() const {
  const ::watrix::proto::MaxSafeDistance* p = max_safe_distance_;
  // @@protoc_insertion_point(field_get:watrix.proto.SendResult.max_safe_distance)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::MaxSafeDistance*>(
      &::watrix::proto::_MaxSafeDistance_default_instance_);
}
inline ::watrix::proto::MaxSafeDistance* SendResult::release_max_safe_distance() {
  // @@protoc_insertion_point(field_release:watrix.proto.SendResult.max_safe_distance)
  clear_has_max_safe_distance();
  ::watrix::proto::MaxSafeDistance* temp = max_safe_distance_;
  max_safe_distance_ = NULL;
  return temp;
}
inline ::watrix::proto::MaxSafeDistance* SendResult::mutable_max_safe_distance() {
  set_has_max_safe_distance();
  if (max_safe_distance_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::MaxSafeDistance>(GetArenaNoVirtual());
    max_safe_distance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SendResult.max_safe_distance)
  return max_safe_distance_;
}
inline void SendResult::set_allocated_max_safe_distance(::watrix::proto::MaxSafeDistance* max_safe_distance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete max_safe_distance_;
  }
  if (max_safe_distance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      max_safe_distance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_safe_distance, submessage_arena);
    }
    set_has_max_safe_distance();
  } else {
    clear_has_max_safe_distance();
  }
  max_safe_distance_ = max_safe_distance;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SendResult.max_safe_distance)
}

// -------------------------------------------------------------------

// SyncPerceptionResult

// optional .watrix.proto.CameraImages source_images = 1;
inline bool SyncPerceptionResult::has_source_images() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncPerceptionResult::set_has_source_images() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncPerceptionResult::clear_has_source_images() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncPerceptionResult::clear_source_images() {
  if (source_images_ != NULL) source_images_->Clear();
  clear_has_source_images();
}
inline const ::watrix::proto::CameraImages& SyncPerceptionResult::_internal_source_images() const {
  return *source_images_;
}
inline const ::watrix::proto::CameraImages& SyncPerceptionResult::source_images() const {
  const ::watrix::proto::CameraImages* p = source_images_;
  // @@protoc_insertion_point(field_get:watrix.proto.SyncPerceptionResult.source_images)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImages*>(
      &::watrix::proto::_CameraImages_default_instance_);
}
inline ::watrix::proto::CameraImages* SyncPerceptionResult::release_source_images() {
  // @@protoc_insertion_point(field_release:watrix.proto.SyncPerceptionResult.source_images)
  clear_has_source_images();
  ::watrix::proto::CameraImages* temp = source_images_;
  source_images_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImages* SyncPerceptionResult::mutable_source_images() {
  set_has_source_images();
  if (source_images_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImages>(GetArenaNoVirtual());
    source_images_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SyncPerceptionResult.source_images)
  return source_images_;
}
inline void SyncPerceptionResult::set_allocated_source_images(::watrix::proto::CameraImages* source_images) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_images_;
  }
  if (source_images) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_images = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_images, submessage_arena);
    }
    set_has_source_images();
  } else {
    clear_has_source_images();
  }
  source_images_ = source_images;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SyncPerceptionResult.source_images)
}

// optional .watrix.proto.CameraImages lane_binary_masks = 2;
inline bool SyncPerceptionResult::has_lane_binary_masks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncPerceptionResult::set_has_lane_binary_masks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncPerceptionResult::clear_has_lane_binary_masks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncPerceptionResult::clear_lane_binary_masks() {
  if (lane_binary_masks_ != NULL) lane_binary_masks_->Clear();
  clear_has_lane_binary_masks();
}
inline const ::watrix::proto::CameraImages& SyncPerceptionResult::_internal_lane_binary_masks() const {
  return *lane_binary_masks_;
}
inline const ::watrix::proto::CameraImages& SyncPerceptionResult::lane_binary_masks() const {
  const ::watrix::proto::CameraImages* p = lane_binary_masks_;
  // @@protoc_insertion_point(field_get:watrix.proto.SyncPerceptionResult.lane_binary_masks)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::CameraImages*>(
      &::watrix::proto::_CameraImages_default_instance_);
}
inline ::watrix::proto::CameraImages* SyncPerceptionResult::release_lane_binary_masks() {
  // @@protoc_insertion_point(field_release:watrix.proto.SyncPerceptionResult.lane_binary_masks)
  clear_has_lane_binary_masks();
  ::watrix::proto::CameraImages* temp = lane_binary_masks_;
  lane_binary_masks_ = NULL;
  return temp;
}
inline ::watrix::proto::CameraImages* SyncPerceptionResult::mutable_lane_binary_masks() {
  set_has_lane_binary_masks();
  if (lane_binary_masks_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::CameraImages>(GetArenaNoVirtual());
    lane_binary_masks_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SyncPerceptionResult.lane_binary_masks)
  return lane_binary_masks_;
}
inline void SyncPerceptionResult::set_allocated_lane_binary_masks(::watrix::proto::CameraImages* lane_binary_masks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_binary_masks_;
  }
  if (lane_binary_masks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_binary_masks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_binary_masks, submessage_arena);
    }
    set_has_lane_binary_masks();
  } else {
    clear_has_lane_binary_masks();
  }
  lane_binary_masks_ = lane_binary_masks;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SyncPerceptionResult.lane_binary_masks)
}

// optional .watrix.proto.DetectionBoxs detection_boxs1 = 3;
inline bool SyncPerceptionResult::has_detection_boxs1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncPerceptionResult::set_has_detection_boxs1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncPerceptionResult::clear_has_detection_boxs1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncPerceptionResult::clear_detection_boxs1() {
  if (detection_boxs1_ != NULL) detection_boxs1_->Clear();
  clear_has_detection_boxs1();
}
inline const ::watrix::proto::DetectionBoxs& SyncPerceptionResult::_internal_detection_boxs1() const {
  return *detection_boxs1_;
}
inline const ::watrix::proto::DetectionBoxs& SyncPerceptionResult::detection_boxs1() const {
  const ::watrix::proto::DetectionBoxs* p = detection_boxs1_;
  // @@protoc_insertion_point(field_get:watrix.proto.SyncPerceptionResult.detection_boxs1)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::DetectionBoxs*>(
      &::watrix::proto::_DetectionBoxs_default_instance_);
}
inline ::watrix::proto::DetectionBoxs* SyncPerceptionResult::release_detection_boxs1() {
  // @@protoc_insertion_point(field_release:watrix.proto.SyncPerceptionResult.detection_boxs1)
  clear_has_detection_boxs1();
  ::watrix::proto::DetectionBoxs* temp = detection_boxs1_;
  detection_boxs1_ = NULL;
  return temp;
}
inline ::watrix::proto::DetectionBoxs* SyncPerceptionResult::mutable_detection_boxs1() {
  set_has_detection_boxs1();
  if (detection_boxs1_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::DetectionBoxs>(GetArenaNoVirtual());
    detection_boxs1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SyncPerceptionResult.detection_boxs1)
  return detection_boxs1_;
}
inline void SyncPerceptionResult::set_allocated_detection_boxs1(::watrix::proto::DetectionBoxs* detection_boxs1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete detection_boxs1_;
  }
  if (detection_boxs1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detection_boxs1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_boxs1, submessage_arena);
    }
    set_has_detection_boxs1();
  } else {
    clear_has_detection_boxs1();
  }
  detection_boxs1_ = detection_boxs1;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SyncPerceptionResult.detection_boxs1)
}

// optional .watrix.proto.DetectionBoxs detection_boxs2 = 4;
inline bool SyncPerceptionResult::has_detection_boxs2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncPerceptionResult::set_has_detection_boxs2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncPerceptionResult::clear_has_detection_boxs2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncPerceptionResult::clear_detection_boxs2() {
  if (detection_boxs2_ != NULL) detection_boxs2_->Clear();
  clear_has_detection_boxs2();
}
inline const ::watrix::proto::DetectionBoxs& SyncPerceptionResult::_internal_detection_boxs2() const {
  return *detection_boxs2_;
}
inline const ::watrix::proto::DetectionBoxs& SyncPerceptionResult::detection_boxs2() const {
  const ::watrix::proto::DetectionBoxs* p = detection_boxs2_;
  // @@protoc_insertion_point(field_get:watrix.proto.SyncPerceptionResult.detection_boxs2)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::DetectionBoxs*>(
      &::watrix::proto::_DetectionBoxs_default_instance_);
}
inline ::watrix::proto::DetectionBoxs* SyncPerceptionResult::release_detection_boxs2() {
  // @@protoc_insertion_point(field_release:watrix.proto.SyncPerceptionResult.detection_boxs2)
  clear_has_detection_boxs2();
  ::watrix::proto::DetectionBoxs* temp = detection_boxs2_;
  detection_boxs2_ = NULL;
  return temp;
}
inline ::watrix::proto::DetectionBoxs* SyncPerceptionResult::mutable_detection_boxs2() {
  set_has_detection_boxs2();
  if (detection_boxs2_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::DetectionBoxs>(GetArenaNoVirtual());
    detection_boxs2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SyncPerceptionResult.detection_boxs2)
  return detection_boxs2_;
}
inline void SyncPerceptionResult::set_allocated_detection_boxs2(::watrix::proto::DetectionBoxs* detection_boxs2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete detection_boxs2_;
  }
  if (detection_boxs2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detection_boxs2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_boxs2, submessage_arena);
    }
    set_has_detection_boxs2();
  } else {
    clear_has_detection_boxs2();
  }
  detection_boxs2_ = detection_boxs2;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SyncPerceptionResult.detection_boxs2)
}

// optional .watrix.proto.MaxSafeDistance max_safe_distance = 5;
inline bool SyncPerceptionResult::has_max_safe_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncPerceptionResult::set_has_max_safe_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncPerceptionResult::clear_has_max_safe_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncPerceptionResult::clear_max_safe_distance() {
  if (max_safe_distance_ != NULL) max_safe_distance_->Clear();
  clear_has_max_safe_distance();
}
inline const ::watrix::proto::MaxSafeDistance& SyncPerceptionResult::_internal_max_safe_distance() const {
  return *max_safe_distance_;
}
inline const ::watrix::proto::MaxSafeDistance& SyncPerceptionResult::max_safe_distance() const {
  const ::watrix::proto::MaxSafeDistance* p = max_safe_distance_;
  // @@protoc_insertion_point(field_get:watrix.proto.SyncPerceptionResult.max_safe_distance)
  return p != NULL ? *p : *reinterpret_cast<const ::watrix::proto::MaxSafeDistance*>(
      &::watrix::proto::_MaxSafeDistance_default_instance_);
}
inline ::watrix::proto::MaxSafeDistance* SyncPerceptionResult::release_max_safe_distance() {
  // @@protoc_insertion_point(field_release:watrix.proto.SyncPerceptionResult.max_safe_distance)
  clear_has_max_safe_distance();
  ::watrix::proto::MaxSafeDistance* temp = max_safe_distance_;
  max_safe_distance_ = NULL;
  return temp;
}
inline ::watrix::proto::MaxSafeDistance* SyncPerceptionResult::mutable_max_safe_distance() {
  set_has_max_safe_distance();
  if (max_safe_distance_ == NULL) {
    auto* p = CreateMaybeMessage<::watrix::proto::MaxSafeDistance>(GetArenaNoVirtual());
    max_safe_distance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:watrix.proto.SyncPerceptionResult.max_safe_distance)
  return max_safe_distance_;
}
inline void SyncPerceptionResult::set_allocated_max_safe_distance(::watrix::proto::MaxSafeDistance* max_safe_distance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete max_safe_distance_;
  }
  if (max_safe_distance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      max_safe_distance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_safe_distance, submessage_arena);
    }
    set_has_max_safe_distance();
  } else {
    clear_has_max_safe_distance();
  }
  max_safe_distance_ = max_safe_distance;
  // @@protoc_insertion_point(field_set_allocated:watrix.proto.SyncPerceptionResult.max_safe_distance)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace watrix

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::watrix::proto::CameraImage_ImageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::watrix::proto::CameraImage_ImageType>() {
  return ::watrix::proto::CameraImage_ImageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_camera_5fimage_2eproto
